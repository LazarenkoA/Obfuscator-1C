package obfuscator

import (
	"context"
	"crypto/sha256"
	"fmt"
	"os"
	"strings"
	"testing"
	"time"

	"github.com/google/uuid"
	"github.com/knetic/govaluate"
	"github.com/stretchr/testify/assert"
)

func TestObfuscate(t *testing.T) {

	code := `

#Область ОбработчикиЭлементовФормы

&НаКлиенте
Процедура ПолныйПутьНачалоВыбора(Элемент, ДанныеВыбора, СтандартнаяОбработка)
	СтандартнаяОбработка = Ложь;
	Д = Новый ДиалогВыбораФайла(РежимДиалогаВыбораФайла.ВыборКаталога);
	Д.Каталог = Объект.ПолныйПуть;
	Д.Показать(Новый ОписаниеОповещения("ПолныйПутьВыбор", ЭтотОбъект));
КонецПроцедуры

&НаКлиенте
Процедура СостояниеРЗНажатие(Элемент, СтандартнаяОбработка)
	СтандартнаяОбработка = Ложь;
	
	Если ТипЗнч(НастройкиРЗ) <> Тип("РасписаниеРегламентногоЗадания") Тогда
		НастройкиРЗ = Новый РасписаниеРегламентногоЗадания;
	КонецЕсли;
	
	Обработчик = Новый ОписаниеОповещения("ИзменитьРегламентноеЗаданиеЗавершение", ЭтотОбъект);
	
	РедактированиеРасписания = Новый ДиалогРасписанияРегламентногоЗадания(НастройкиРЗ);
	РедактированиеРасписания.Показать(Обработчик);
КонецПроцедуры

&НаКлиенте
Процедура ИзменитьРегламентноеЗаданиеЗавершение(Расписание, ДополнительныеПараметры) Экспорт
	Если Расписание = Неопределено Тогда
		Возврат;
	КонецЕсли;
	
	НастройкиРЗ = Расписание;
	СостояниеРЗ = Строка(Расписание);
	Если ЗагружатьАвтоматически = Ложь Тогда
		ЗагружатьАвтоматически = Истина;
	КонецЕсли;
	
	Модифицированность = Истина;
КонецПроцедуры

&НаКлиенте
Процедура ЗагружатьАвтоматическиПриИзменении(Элемент)
	Если ЗагружатьАвтоматически 
		И НастройкиРЗ = Неопределено Тогда
			СостояниеРЗНажатие(Неопределено, Неопределено);
	ИначеЕсли НЕ ЗагружатьАвтоматически 
		И НастройкиРЗ <> Неопределено Тогда
		НастройкиРЗ = Неопределено;
		ИдентификаторРЗ = Неопределено;
		УстановитьПредставлениеСостоянияРЗ(ЭтаФорма);
	КонецЕсли;
КонецПроцедуры

&НаСервере
Процедура УстановитьСостояниеРЗ()     
		НастройкиРЗ = Неопределено; ЗагружатьАвтоматически = Ложь; 	Если ЗначениеЗаполнено(Объект.Ссылка) Тогда    	Если (Объект.ИдентификаторРЗ <> Новый УникальныйИдентификатор("00000000-0000-0000-0000-000000000000")) Тогда 		РЗ = РегламентныеЗадания.НайтиПоУникальномуИдентификатору(Объект.ИдентификаторРЗ);                																																																																					 сообщить("Аня жопа");
		Если РЗ<>Неопределено  			И РЗ.Использование Тогда 			ЗагружатьАвтоматически = Истина;					НастройкиРЗ = РЗ.Расписание; 		КонецЕсли;
	КонецЕсли; 
КонецЕсли;
УстановитьПредставлениеСостоянияРЗ(ЭтаФорма);
КонецПроцедуры

&НаКлиентеНаСервереБезКонтекста
Процедура УстановитьПредставлениеСостоянияРЗ(Форма)
Форма.СостояниеРЗ = ?(Форма.ЗагружатьАвтоматически, Строка(Форма.НастройкиРЗ), "<Отключено>");
КонецПроцедуры

&НаКлиенте
Процедура ПолныйПутьВыбор(Результат, Параметры) Экспорт
	Если Результат <> Неопределено И Результат.Количество() Тогда
		Объект.ПолныйПуть = Результат[0];
	КонецЕсли;
КонецПроцедуры

&НаКлиенте
Процедура ТипЗамераПриИзменении(Элемент)
	Если Объект.ТипЗамера=ПредопределенноеЗначение("Перечисление.ТипыЗамеров.Произвольный") Тогда
		Элементы.ДополнительнаяОбработка.Видимость = Истина;
	Иначе
		Элементы.ДополнительнаяОбработка.Видимость = Ложь;
	КонецЕсли;
КонецПроцедуры

#КонецОбласти

#Область ОбработчикиФормы

&НаКлиенте
Процедура ПриОткрытии(Отказ)
	ТипЗамераПриИзменении(Неопределено);
	ОбновитьДоступностьДополнительныхЭлементовСпика();
КонецПроцедуры

&НаСервере
Процедура ПриСозданииНаСервере(Отказ, СтандартнаяОбработка)
	ПриСозданииЧтенииНаСервере();
КонецПроцедуры

&НаСервере
Процедура ПриСозданииЧтенииНаСервере()
	УстановитьСостояниеРЗ();
	Если ЗначениеЗаполнено(Объект.Ссылка) Тогда
		ФильтрТипПроцесса = ОбщегоНазначения.ЗначениеРеквизитаОбъекта(Объект.Ссылка, "ФильтрТипПроцесса").Получить();
		ФильтрТипСобытия = ОбщегоНазначения.ЗначениеРеквизитаОбъекта(Объект.Ссылка, "ФильтрТипСобытия").Получить();
	КонецЕсли;
	УстановитьЗаголовокФильтров(ЭтаФорма);
КонецПроцедуры

&НаКлиенте
Процедура НачалоПериодаПриИзменении(Элемент)
	НачатьУстановкуЗаголовкаФильтров();
КонецПроцедуры

&НаКлиенте
Процедура КонецПериодаПриИзменении(Элемент)
	НачатьУстановкуЗаголовкаФильтров();
КонецПроцедуры

&НаКлиенте
Процедура ФильтрСвойсваСобытияПриИзменении(Элемент)
	НачатьУстановкуЗаголовкаФильтров();
КонецПроцедуры


&НаСервере
Процедура ПриЧтенииНаСервере(ТекущийОбъект)
	УстановитьСостояниеРЗ();
КонецПроцедуры

&НаСервере
Процедура ПередЗаписьюНаСервере(Отказ, ТекущийОбъект, ПараметрыЗаписи)
	ТекущийОбъект.ДополнительныеСвойства.Вставить("ЗагружатьАвтоматически", ЗагружатьАвтоматически);
	ТекущийОбъект.ДополнительныеСвойства.Вставить("НастройкиРЗ", НастройкиРЗ);
	ТекущийОбъект.ФильтрТипПроцесса = Новый ХранилищеЗначения(ФильтрТипПроцесса);
	ТекущийОбъект.ФильтрТипСобытия = Новый ХранилищеЗначения(ФильтрТипСобытия);
КонецПроцедуры

&НаКлиентеНаСервереБезКонтекста
Процедура УстановитьЗаголовокФильтров(Форма)
	СписокФильтров = "";
	Если ЗначениеЗаполнено(Форма.Объект.НачалоПериода) ИЛИ ЗначениеЗаполнено(Форма.Объект.КонецПериода) Тогда
		 СписокФильтров = СписокФильтров + ?(СписокФильтров = "", "", "; ") + "Период";
	КонецЕсли;
	Если Форма.ФильтрТипПроцесса.Количество() Тогда
		 СписокФильтров = СписокФильтров + ?(СписокФильтров = "", "", "; ") + "Процессы";
	КонецЕсли;
	Если Форма.ФильтрТипСобытия.Количество() Тогда
		 СписокФильтров = СписокФильтров + ?(СписокФильтров = "", "", "; ") + "События";
	КонецЕсли;
	Если ЗначениеЗаполнено(Форма.Объект.ФильтрСвойстваСобытия) Тогда
		 СписокФильтров = СписокФильтров + ?(СписокФильтров = "", "", "; ") + "Свойства";
	КонецЕсли;
	Если ЗначениеЗаполнено(Форма.Объект.ФильтрДлительность) Тогда
		 СписокФильтров = СписокФильтров + ?(СписокФильтров = "", "", "; ") + "Длительность";
	КонецЕсли;
	Если СписокФильтров = "" Тогда
		СписокФильтров = "не установлены";
	КонецЕсли;
	Форма.Элементы.ГруппаФильтры.Заголовок = СтрШаблон("Фильтр (%1)", СписокФильтров);
КонецПроцедуры

&НаКлиенте
Процедура ФильтрТипПроцессаНачалоВыбора(Элемент, ДанныеВыбора, СтандартнаяОбработка)
	СтандартнаяОбработка = Ложь;
	Спс = ПолучитьСписокСПометками("Процессы", ФильтрТипПроцесса);
	Спс.ПоказатьОтметкуЭлементов(Новый ОписаниеОповещения("ФильтрВыборЗавершение", ЭтотОбъект, ФильтрТипПроцесса));
КонецПроцедуры

&НаКлиенте
Процедура ФильтрТипСобытияНачалоВыбора(Элемент, ДанныеВыбора, СтандартнаяОбработка)
	СтандартнаяОбработка = Ложь;
	Спс = ПолучитьСписокСПометками("События", ФильтрТипСобытия);
	Спс.ПоказатьОтметкуЭлементов(Новый ОписаниеОповещения("ФильтрВыборЗавершение", ЭтотОбъект, ФильтрТипСобытия));
КонецПроцедуры

&НаКлиенте
Процедура ФильтрВыборЗавершение(Результат, Параметры) Экспорт
	Если Результат<>Неопределено Тогда
		ЗаполнитьСписокПоОтметкам(Результат, Параметры);
		Модифицированность = Истина;
		НачатьУстановкуЗаголовкаФильтров();	
	КонецЕсли;	           
	
		
	
КонецПроцедуры

&НаКлиенте
Процедура ПериодОчистить(Команда)
	Объект.НачалоПериода = Неопределено;
	Объект.КонецПериода = Неопределено;
	НачатьУстановкуЗаголовкаФильтров();
КонецПроцедуры

&НаКлиенте
Процедура ОчиститьЗамер(Команда)
	Если ЗначениеЗаполнено(Объект.Ссылка) Тогда
		ОчиститьЗамерСервер(Объект.Ссылка);
		ПоказатьПредупреждение(,"Готово");
	КонецЕсли;
КонецПроцедуры

&НаСервереБезКонтекста
Процедура ОчиститьЗамерСервер(Ссылка)
	ОбновлениеДанныхРегламентное.ВыполнитьОчисткуПоНастройке(Новый Структура("Ссылка,ГлубинаХранения", Ссылка, -1), Истина);
КонецПроцедуры

&НаКлиенте
Процедура ЗаполнитьСписокПоОтметкам(Результат, Параметры)
	Параметры.Очистить();
	Для Каждого эл из Результат Цикл
		Если эл.Пометка Тогда
			Параметры.Добавить(эл.Значение);
		КонецЕсли;
	КонецЦикла;
КонецПроцедуры

&НаСервереБезКонтекста
Функция ПолучитьСписокСПометками(ИмяСправочника, Фильтр)
	Результат = Новый СписокЗначений();
	Запрос = Новый Запрос("ВЫБРАТЬ Ссылка КАК Ссылка ИЗ Справочник." + ИмяСправочника + " ГДЕ НЕ ПометкаУдаления УПОРЯДОЧИТЬ ПО Наименование");
	Результат.ЗагрузитьЗначения(Запрос.Выполнить().Выгрузить().ВыгрузитьКолонку("Ссылка"));
	Для Каждого эл из Фильтр Цикл
		элрезультата = Результат.НайтиПоЗначению(эл.Значение);
		Если элрезультата<>Неопределено Тогда
			элрезультата.Пометка = Истина;
		КонецЕсли;
	КонецЦикла;
	Возврат Результат;
КонецФункции

&НаКлиенте
Процедура ФильтрТипПроцессаОчистка(Элемент, СтандартнаяОбработка)
	СтандартнаяОбработка = Ложь;
	ФильтрТипПроцесса.Очистить();
	Модифицированность = Истина;
	НачатьУстановкуЗаголовкаФильтров();
КонецПроцедуры

&НаКлиенте
Процедура ФильтрТипСобытияОчистка(Элемент, СтандартнаяОбработка)
	СтандартнаяОбработка = Ложь;
	ФильтрТипСобытия.Очистить();
	Модифицированность = Истина;
	НачатьУстановкуЗаголовкаФильтров();
КонецПроцедуры

&НаКлиенте
Процедура НачатьУстановкуЗаголовкаФильтров()
	ПодключитьОбработчикОжидания("ВыполнитьУстановкуЗаголовкаФильтров", 0.1, Истина);
КонецПроцедуры 

&НаКлиенте
Процедура ВыполнитьУстановкуЗаголовкаФильтров() Экспорт
	УстановитьЗаголовокФильтров(ЭтаФорма);
КонецПроцедуры

&НаКлиенте
Процедура ФильтрДлительностьПриИзменении(Элемент)
	НачатьУстановкуЗаголовкаФильтров();
КонецПроцедуры

&НаКлиенте
Процедура ДополнительныеПоляСвойствДляСпискаСвойствоПриИзменении(Элемент)
	ТекущиеДанные = Элементы.ДополнительныеПоляСвойствДляСписка.ТекущиеДанные;
	Если ТекущиеДанные=Неопределено Тогда
		Возврат;
	КонецЕсли;
	ИмяРеквизита = ОбщегоНазначенияВызовСервера.ЗначениеРеквизитаОбъекта(ТекущиеДанные.Свойство,"Наименование");
	Если ОбщегоНазначенияКлиентСервер.ПроверкаВалидностиЭлемента(ИмяРеквизита)=Ложь Тогда
		ИмяРеквизита = "["+ИмяРеквизита+"]";
	КонецЕсли;
	ТекущиеДанные.ИмяРеквизита = ИмяРеквизита;
КонецПроцедуры

&НаКлиенте
Процедура АктуализироватьРеквизиты(Команда)
	Для каждого стр из Объект.ДополнительныеПоляСвойствДляСписка Цикл
		
		ИмяРеквизита = ОбщегоНазначенияВызовСервера.ЗначениеРеквизитаОбъекта(стр.Свойство,"Наименование");
		Если ОбщегоНазначенияКлиентСервер.ПроверкаВалидностиЭлемента(ИмяРеквизита)=Ложь Тогда
			ИмяРеквизита = "["+ИмяРеквизита+"]";
		КонецЕсли;
		
		Если ИмяРеквизита<>стр.ИмяРеквизита Тогда
			стр.ИмяРеквизита = ИмяРеквизита;
		КонецЕсли;
			
	КонецЦикла;
КонецПроцедуры

&НаКлиенте
Процедура ДополнятьСписокНаборомПолейПриИзменении(Элемент)
	ОбновитьДоступностьДополнительныхЭлементовСпика();	
КонецПроцедуры

&НаКлиенте
Процедура ОбновитьДоступностьДополнительныхЭлементовСпика()
	Элементы.ГруппаДополнительныеПоляДляСписка.Видимость = Объект.ДополнятьСписокНаборомПолей=Истина;
КонецПроцедуры

#КонецОбласти


`

	obf := NewObfuscatory(context.Background(), Config{
		RepExpByTernary:  true,
		RepLoopByGoto:    true,
		RepExpByEval:     true,
		HideString:       true,
		ChangeConditions: true,
		AppendGarbage:    true,
	})
	obCode, err := obf.Obfuscate(code)
	if err != nil {
		fmt.Println(err)
		return
	}

	file, _ := os.Create(uuid.NewString())
	file.WriteString(obCode)
	file.Close()

}

func TestObfuscateLoop(t *testing.T) {

	code := `&НаСервереБезКонтекста
			Функция Команда1НаСервере()

				Для а = 0 По 100 Цикл
					Сообщить(а);	
				КонецЦикла;
				
				б = 0;
				Пока б < 100 Цикл
					Сообщить(б);
					б = б+1;
				КонецЦикла;
				
				fd = "dssdfdf";
				Для Каждого а Из Чтото Цикл
					Сообщить(а);	
				КонецЦикла;

			 КонецФункции`

	obf := NewObfuscatory(context.Background(), Config{RepLoopByGoto: false})
	obCode, err := obf.Obfuscate(code)
	if err != nil {
		fmt.Println(err)
		return
	}

	// должны быть равны
	assert.Equal(t, true, compareHashes(code, obCode))

	obf = NewObfuscatory(context.Background(), Config{RepLoopByGoto: true})
	obCode, err = obf.Obfuscate(code)
	if err != nil {
		fmt.Println(err)
		return
	}

	// не должны быть равны
	assert.Equal(t, false, compareHashes(code, obCode))
}

func TestShuffleExp(t *testing.T) {
	//
	// 	code := `&НаСервереБезКонтекста
	// 			Процедура Команда1НаСервере()
	//
	// 			а = 1;
	// 			Сообщить(а);
	// 			а = а +1;
	// 			Сообщить(а);
	// 			а = а +1;
	// 			Сообщить(а);
	// 			а = а +1;
	// 			Сообщить(а);
	//
	// Если Истина Тогда
	// а = а +1;
	// 			Сообщить(а);
	// а = а +1;
	// 			Сообщить(а);
	// КонецЕсли;
	// а = а +1;
	// 			Сообщить(а);
	// а = а +1;
	// 			Сообщить(а);
	//
	// 			 КонецПроцедуры`
	//
	// 	obf := NewObfuscatory(context.Background(), Config{ShuffleExpressions: true})
	// 	obCode, err := obf.Obfuscate(code)
	// 	if err != nil {
	// 		fmt.Println(err)
	// 		return
	// 	}
	//
	// 	fmt.Println(obCode)
}

func TestGenCondition(t *testing.T) {
	ctx, _ := context.WithTimeout(context.Background(), time.Millisecond*500)
	obf := NewObfuscatory(ctx, Config{})

	for c := range obf.falseCondition {
		expression, _ := govaluate.NewEvaluableExpression(c)
		result, _ := expression.Evaluate(nil)
		if v, ok := result.(bool); v && ok {
			t.Fatal(c, "expression must be false")
		}
	}

	for c := range obf.trueCondition {
		expression, _ := govaluate.NewEvaluableExpression(c)
		result, _ := expression.Evaluate(nil)
		if v, ok := result.(bool); v && !ok {
			t.Fatal(c, "expression must be true")
		}
	}
}

func compareHashes(str1, str2 string) bool {
	str1 = strings.ReplaceAll(str1, " ", "")
	str1 = strings.ReplaceAll(str1, "\t", "")
	str1 = strings.ReplaceAll(str1, "\n", "")

	str2 = strings.ReplaceAll(str2, " ", "")
	str2 = strings.ReplaceAll(str2, "\t", "")
	str2 = strings.ReplaceAll(str2, "\n", "")

	hash1 := sha256.Sum256([]byte(strings.ToLower(str1)))
	hash2 := sha256.Sum256([]byte(strings.ToLower(str2)))

	return hash1 == hash2
}
